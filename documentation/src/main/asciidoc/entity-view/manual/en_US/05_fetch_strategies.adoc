[[anchor-fetch-strategies]]
== Fetch strategies

There are multiple different fetch strategies available for fetching. Right now, a fetch strategy can only be applied on a correlated mapping,
but soon will also be able to be specified for any other mapping. Also see https://github.com/Blazebit/blaze-persistence/issues/323[#323] for further information.

NOTE: `@MappingSubquery` is the only mapping that doesn't support overriding the fetch strategy. It will always use the `JOIN` strategy

// Any attribute in an entity view can be fetched separately(that's the idea, but only implemented for correlation right now)

Every fetch strategy has some pros and cons, but generally, the `JOIN` fetch strategy is the one that is good enough most of the time.
Unless you can't use the `JOIN` strategy because your JPA provider doesn't support entity joins, you should always stick with it by default
and only change the strategy on a case by case basis.

=== Join fetch strategy

The `JOIN` strategy is not only the default, but also the one that makes mostly sense.
In case of correlated mappings it will result in a `LEFT JOIN` link:{core_doc}#anchor-entity-joins[entity join] of the correlated entity type.
The correlation expression created by the `CorrelationProvider` will be used in the `ON` condition.

For an example query that is generated by this strategy take a look at the <<anchor-correlation-mappings,correlation mappings>> chapter.

NOTE: Entity joins are only supported in newer versions of JPA providers(Hibernate 5.1+, EclipseLink 2.4+, DataNucleus 5+)

=== Select fetch strategy

In general, the `SELECT` strategy will create a separate query for every attribute that uses it.
It will collect up to _N_ instances and then will execute that query to actually fetch the values for the attributes of the instances.
The parameter _N_ is the batch size that can be configured at multiple levels.

Let's look at an example that shows what happens

[source,java]
----
@EntityView(Cat.class)
public interface CatView {

    @IdMapping("id")
    Long getId();

    @BatchFetch(20) # <1>
    @MappingCorrelated(
        correlationBasis = "age",
        correlator = PersonAgeCorrelationProvider.class,
        correlationResult = "pers",
        fetch = FetchStrategy.SELECT
    )
    Set<Person> getSameAgedPersons();

    static class PersonAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            builder.correlate(Person.class, "pers")
                .on("pers.age").inExpressions(correlationExpression)
            .end();
        }

    }
}
----
<1> Defines the batch size to use for loading

When using this entity view, there are 2 queries that are generated.

[.Main query]
[source,sql]
----
SELECT cat.id, cat.age
FROM Cat cat
----

The main query will fetch the `correlationBasis` and all the other attributes.

[.Correlation query]
[source,sql]
----
SELECT
    TREAT_LONG(correlationParams.value),
    pers
FROM Person pers,
     VALUES ((?), (?), ...) correlationParams # <1>
WHERE pers.age = TREAT_LONG(correlationParams.value)
----
<1> Actually there will be 20 question marks here because of the defined batch size of 20

The correlation query on the other hand will select the correlation value and the `Person` instances with an age matching any of the `correlationParams` values.
What you see here is the use of the link:{core_doc}#anchor-values-clause[`VALUES` clause] for making multiple values available like a table for querying which is required when wanting to select the correlation value.
Selecting the actual correlation value via `TREAT_LONG(correlationParams.value)` along with the `Person` is necessary to be able to correlate the instances to the instance of the main query.

Depending on how many different values for `age` there are(cardinality), the correlation query might get executed multiple times.
In general, the runtime will collect up to _batch size_ different values and then execute the correlation query for these values.
Results for a correlation value are cached during the querying to avoid querying the same correlation values multiple times in different batches.

This strategy works best when the cardinality of the `correlationBasis` is low i.e. there are only a few distinct values.
If the cardinality is high and the batch size is too low, this can lead to something similar as an _N + 1 select_ known from lazy loading of collection elements.
You could theoretically choose a very big batch size to be able to handle more correlation values per query, but beware that there are limits to the efficiency of this approach.
Also beware that the amount of possible parameters might be limited by the DBMS. A value of _1000_ for the batch size shouldn't generally be a problem for a DBMS,
but before you configure such a high value, look into the <<anchor-subselect-fetch-strategy,subselect>> strategy which might be more appropriate for higher cardinalities.

==== Select fetch strategy with batching

Apart from using the `@BatchFetch` annotation, there are some other ways to define a batch size for fetching of an attribute.

===== Batch size default per entity view

A default batch size can be defined by setting the property <<default-batch-size,`com.blazebit.persistence.view.batch_size`>> via link:{entity_view_jdoc}/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)[`EntityViewSetting.setProperty()`].
The value serves as default value and can be overridden on a per attribute basis.

===== Batch size per entity view attribute

The batch size for a specific attribute can be defined either by using the `@BatchFetch` annotation or by setting the <<default-batch-size,`com.blazebit.persistence.view.batch_size`>> property suffixed with the attribute name.
In order to set the batch size for an attribute named _someAttribute_ you have to set the property `com.blazebit.persistence.view.batch_size.someAttribute` via link:{entity_view_jdoc}/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)[`EntityViewSetting.setProperty()`].
The path to the attribute is based on the entity view which is queried and can also be deep i.e. `someSubview.someAttribute`.

[[anchor-select-fetch-strategy-view-root]]
==== Select fetch strategy with VIEW_ROOT

One possible problem with this strategy might arise when using the `VIEW_ROOT` function. The use of two correlation keys i.e. the view root and the correlation basis,
will affect the way the batching can be done. Before querying for the correlated date, the runtime will determine the cardinality of the view root ids and the correlation basis values.
After that, it will group the values with higher cardinality by the values with lower cardinality to be able to do efficient batching.

Let's see what that means

[source,java]
----
@EntityView(Cat.class)
public interface CatView {

    @IdMapping("id")
    Long getId();

    Set<KittenCatView> getKittens();

}

@EntityView(Cat.class)
public interface KittenCatView {

    @IdMapping("id")
    Long getId();

    @BatchFetch(20)
    @MappingCorrelated(
        correlationBasis = "age",
        correlator = CatAgeCorrelationProvider.class,
        correlationResult = "correlatedCat",
        fetch = FetchStrategy.SELECT
    )
    Set<Cat> getSameAgedCats();

    static class CatAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            builder.correlate(Cat.class, "correlatedCat")
                .on("correlatedCat.age").inExpressions(correlationExpression)
                .on("correlatedCat.id").notInExpressions("VIEW_ROOT(id)")
            .end();
        }

    }
}
----

In this example the batching might happen either for view roots or correlation basis values depending on the data.
If the number of distinct view root ids is lower than the number of distinct correlation basis values, the correlation basis values are grouped by view root ids.
The runtime will then execute a batched query for every view root id.

The good thing is, the runtime will adapt based on the data to minimize the number of queries, but still, if the cardinality is high, this can result in many queries being executed.

===== Batching expectation fine tuning

By default the runtime assumes that the `VIEW_ROOT` function is not used and generates a query that batches correlation basis values.
If this assumption fails because the `VIEW_ROOT` function is used and the batching is done based on view root ids, a new query has to be built.

The way the `VIEW_ROOT` function is implemented requires to invoke the `CorrelationProvider` again for building the new query.

To avoid this unnecessary rebuilding of the query, you can specify the batch expectation for all attributes by setting the property
<<expect-batch-correlation-values,`com.blazebit.persistence.view.batch_correlation_values`>> via link:{entity_view_jdoc}/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)[`EntityViewSetting.setProperty()`]
to `false` if batching is expected to be done on a view root id basis. The value serves as default value and can be overridden on a per attribute basis by suffixing the property name with the attribute name.
In order to set the batch expectation for an attribute named _someAttribute_ you have to set the property `com.blazebit.persistence.view.batch_correlation_values.someAttribute` via link:{entity_view_jdoc}/persistence/view/EntityViewSetting.html#setProperty(java.lang.String,%20java.lang.Object)[`EntityViewSetting.setProperty()`].
The path to the attribute is based on the entity view which is queried and can also be deep i.e. `someSubview.someAttribute`.

[[anchor-subselect-fetch-strategy]]
=== Subselect fetch strategy

The `SUBSELECT` strategy will create one query for every attribute that uses it and is especially efficient for bigger collections.
It creates a separate query based on the outer query and applies the `CorrelationProvider` to it.

WARNING: Correlating subviews that contain collections when using `firstResult`/`maxResults` or applying an entity view on queries that use `ORDER BY` select aliases does not yet work. For more information also see https://github.com/Blazebit/blaze-persistence/issues/370[#370]

Let's look at an example that shows what happens

[source,java]
----
@EntityView(Cat.class)
public interface CatView {

    @IdMapping("id")
    Long getId();

    @MappingCorrelated(
        correlationBasis = "age",
        correlator = PersonAgeCorrelationProvider.class,
        correlationResult = "pers",
        fetch = FetchStrategy.SUBSELECT
    )
    Set<Person> getSameAgedPersons();

    static class PersonAgeCorrelationProvider implements CorrelationProvider {

        @Override
        public void applyCorrelation(CorrelationBuilder builder, String correlationExpression) {
            builder.correlate(Person.class, "pers")
                .on("pers.age").inExpressions(correlationExpression)
            .end();
        }

    }
}
----

When using this entity view, there are 2 queries that are generated.

[.Main query]
[source,sql]
----
SELECT cat.id, cat.age
FROM Cat cat
----

The main query will fetch the `correlationBasis` and all the other attributes.

[.Correlation query]
[source,sql]
----
SELECT
    cat.age,
    pers
FROM Cat cat,
     Person pers
WHERE pers.age = cat.age
----

The correlation query looks very similar since it's based on the main query, but has a custom select clause.
It selects the correlation key as well as the attributes for the target representation in the main entity view.

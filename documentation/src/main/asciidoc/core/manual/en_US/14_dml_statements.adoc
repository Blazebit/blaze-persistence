== DML statements

Next to the support for `SELECT` statements, {projectname} also has support for

* `UPDATE`
* `DELETE`
* `INSERT ... SELECT`

Apart from support for DML for JPA entity types, there is also support for DML for entity collections.
The construction of query builders for such statements works through the link:{core_jdoc}/persistence/CriteriaBuilderFactory.html[`CriteriaBuilderFactory`] API.

=== DELETE statement

The `DELETE` statement deletes entities that satisfy the `WHERE` clause of the statement.
A delete builder can be created via link:{core_jdoc}/persistence/CriteriaBuilderFactory.html#delete(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)[`CriteriaBuilderFactory.delete()`].

[source,java]
----
DeleteCriteriaBuilder<Cat> cb = cbf.delete(em, Cat.class, "cat")
    .where("cat.name").isNull();
----

[source,sql]
----
DELETE FROM Cat cat
WHERE cat.name IS NULL
----

You can immediately execute the query by calling link:{core_jdoc}/persistence/Executable.html#executeUpdate()[`executeUpdate()`]
or create a JPA `Query` by calling link:{core_jdoc}/persistence/Executable.html#getQuery()[`getQuery()`].

NOTE: Since a `DELETE` statement can't have joins, implicit joins generated by deep path expressions are disallowed. Use an `EXISTS` subquery if you need to join relations.

WARNING: Currently you can't make use of advanced SQL features like CTEs when having a polymorphic `DELETE` except for single table inheritance. Also see https://github.com/Blazebit/blaze-persistence/issues/345[#345]

TIP: If your DBMS supports it, cascading deletes will be implemented as CTEs when deleting entities through this API.
// TIP: If your DBMS supports it, cascading and polymorphic `DELETES` statements will be implemented as CTEs when deleting entities through this API.

=== DELETE collection statement

The `DELETE` collection statement deletes collection entries of entities that satisfy the `WHERE` clause of the statement.
A collection delete builder can be created via link:{core_jdoc}/persistence/CriteriaBuilderFactory.html#deleteCollection(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)[`CriteriaBuilderFactory.deleteCollection()`].
The statement only works on collections that have a join or collection table.

[source,java]
----
DeleteCriteriaBuilder<Cat> cb = cbf.deleteCollection(em, Cat.class, "kittens", "cat")
    .whereExists()
        .from(Cat.class, "subCat")
        .where("cat.id").eqExpression("subCat.id")
        .where("subCat.name").isNull()
    .end();
----

The alias `cat` or in general, an delete collection statement alias only allows access to the join or collection table related attributes.
Generally, these attributes are

* The source id i.e. `cat.id`
* The target id i.e. `cat.kittens.id`
* The collection index/key i.e. `KEY(cat.kittens)`

[source,sql]
----
DELETE FROM Cat(kittens) cat
WHERE EXISTS(
    SELECT 1 FROM Cat subCat
    WHERE cat.id = subCat.id
      AND cat.name IS NULL
)
----

You can immediately execute the query by calling link:{core_jdoc}/persistence/Executable.html#executeUpdate()[`executeUpdate()`]
or create a JPA `Query` by calling link:{core_jdoc}/persistence/Executable.html#getQuery()[`getQuery()`].

=== UPDATE statement

The `UPDATE` statement updates attributes as specified in the `SET` clause on entities that satisfy the `WHERE` clause of the statement.
An update builder can be created via link:{core_jdoc}/persistence/CriteriaBuilderFactory.html#update(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)[`CriteriaBuilderFactory.update()`].

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .set("name")
        .from(Person.class, "p")
        .where("p").eqExpression("cat.owner")
        .select("CONCAT(p.name, '''s cat')")
    .end()
    .where("name").isNull();
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = (
    SELECT CONCAT(p.name, '''s cat')
    FROM Person p
    WHERE p = cat.owner
)
WHERE cat.name IS NULL
----

There are multiple `set()` variants to be able to cover all possible expressions.

link:{core_jdoc}/persistence/BaseUpdateCriteriaBuilder.html#set(java.lang.String,%20java.lang.Object)[`set(String, Object)`]::
Set the attribute to the given value. This will create an implicit parameter expression and set the value.

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .set("name", "Billy2")
    .where("name").eq("Billy");
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = :param_1
WHERE cat.name = :param_2
----

link:{core_jdoc}/persistence/BaseUpdateCriteriaBuilder.html#set(java.lang.String)[`set(String)`]::
Starts a subquery builder for the attribute.

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .set("name")
        .from(Person.class, "p")
        .where("p").eqExpression("cat.owner")
        .select("CONCAT(p.name, '''s cat')")
    .end()
    .where("cat.name").eq("Billy");
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = (
    SELECT CONCAT(p.name, '''s cat')
    FROM Person p
    WHERE p = cat.owner
)
WHERE cat.name = :param_1
----

link:{core_jdoc}/persistence/BaseUpdateCriteriaBuilder.html#setExpression(java.lang.String,%20java.lang.String)[`setExpression(String, String)`]::
Uses the given expression for the assignment to the attribute.

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .setExpression("name", "UPPER(name)")
    .where("cat.name").eq("Billy");
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = UPPER(cat.name)
WHERE cat.name = :param_1
----

link:{core_jdoc}/persistence/BaseUpdateCriteriaBuilder.html#setSubqueries(java.lang.String,%20java.lang.String)[`setSubqueries(String, String)`]::
Starts a subquery builder capable of handling multiple subqueries and assigns the given `expression` to the attribute.
Subqueries are started with `with(String subqueryAlias)` and aliases occurring in the expression will be replaced by the respective subquery expressions.

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .setSubqueries("name", "CONCAT(ownerSubquery, ' the cat'")
        .with("ownerSubquery")
            .from(Person.class, "p")
            .where("p").eqExpression("cat.owner")
            .select("p.name")
        .end()
    .end()
    .where("cat.name").eq("Billy");
----

[source,sql]
----
UPDATE Cat cat
SET cat.name = CONCAT((
    SELECT p.name
    FROM Person p
    WHERE p = cat.owner
), '''s cat')
WHERE cat.name = :param_1
----

WARNING: Currently there is no possibility to do a `VERSIONED` update like you could do with e.g. Hibernate.

You can immediately execute the query by calling link:{core_jdoc}/persistence/Executable.html#executeUpdate()[`executeUpdate()`]
or create a JPA `Query` by calling link:{core_jdoc}/persistence/Executable.html#getQuery()[`getQuery()`].

NOTE: Since an `UPDATE` statement can't have joins, implicit joins generated by deep path expressions are disallowed. Use an `EXISTS` subquery if you need to join relations in the `WHERE` clause or a scalar subquery if you need joins for the `SET` clause.

WARNING: Currently you can't make use of advanced SQL features like CTEs when having a polymorphic `UPDATE` except for single table inheritance. Also see https://github.com/Blazebit/blaze-persistence/issues/345[#345]

// TIP: If your DBMS supports it, polymorphic `UPDATE` statements will be implemented as CTEs when updating entities through this API.

=== UPDATE collection statement

The `UPDATE` collection statement updates attributes as specified in the `SET` clause on entries of a collection of entities that satisfy the `WHERE` clause of the statement.
A collection update builder can be created via link:{core_jdoc}/persistence/CriteriaBuilderFactory.html#updateCollection(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)[`CriteriaBuilderFactory.updateCollection()`].
The statement only works on collections that have a join or collection table.

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.updateCollection(em, Cat.class, "kittens", "cat")
    .set("cat.id", 2)
    .where("cat.id").eq(1);
----

The alias `cat` or in general, an update collection statement alias only allows access to the join or collection table related attributes.
Generally, these attributes are

* The source id i.e. `cat.id`
* The target id i.e. `cat.kittens.id`
* The collection index/key i.e. `KEY(cat.kittens)`

The logical SQL for this _re-parenting query_ looks like

[source,sql]
----
UPDATE Cat(kittens) cat
SET cat.id = :param_1
WHERE cat.id = :param_2
----

This will cause all kittens that previously were associated with the cat with id 1 now to be the kittens of the cat with id 2.

=== INSERT-SELECT statement

The `INSERT-SELECT` statement allows to create new entities based on result of a `SELECT` query.
An insert builder can be created via link:{core_jdoc}/persistence/CriteriaBuilderFactory.html#insert(javax.persistence.EntityManager,%20java.lang.Class)[`CriteriaBuilderFactory.insert()`].

WARNING: This feature is currently only supported with Hibernate!

Let's consider a simple entity class for `INSERT` statement examples

[source,java]
----
@Entity
public class Pet {

    @Id
    @GeneratedValue
    private Long id;
    @ManyToOne(optional = false)
    private Cat cat;
}
----

[source,java]
----
InsertCriteriaBuilder<Cat> cb = cbf.insert(em, Pet.class)
    .from(Cat.class, "c")
    .bind("cat").select("c")
    .where("owner").isNotNull();
----

[source,sql]
----
INSERT INTO Pet(cat)
SELECT c
FROM Cat c
WHERE c.owner IS NOT NULL
----

The link:{core_jdoc}/persistence/BaseInsertCriteriaBuilder.html#bind(java.lang.String)[`bind()`] method allows to bind any select expression to an attribute of the `Pet` entity.
You can also bind values directly with link:{core_jdoc}/persistence/BaseInsertCriteriaBuilder.html#bind(java.lang.String,%20java.lang.Object)[`bind(String, Object)`] if you want.

NOTE: Hibernate 4.2 does not support parameters in the `SELECT` clause, so you will have to render values as literals instead.

As you can see, we didn't specify the `id` attribute. This is because it's value is going to be generated by the database.

NOTE: When using Hibernate with embedded ids, you *must* map all the columns as *basic values*(no relations) directly into the entity itself, otherwise you won't be able to assign a value to the attributes/columns.

WARNING: When using Oracle, generated identifiers currently don't work. Also see https://github.com/Blazebit/blaze-persistence/issues/306[#306]

=== INSERT-SELECT collection statement

The `INSERT-SELECT` collection statement inserts new collection entries.
A collection insert builder can be created via link:{core_jdoc}/persistence/CriteriaBuilderFactory.html#insertCollection(javax.persistence.EntityManager,%20java.lang.Class,%20java.lang.String)[`CriteriaBuilderFactory.insertCollection()`].
The statement only works on collections that have a join or collection table.

[source,java]
----
InsertCriteriaBuilder<Cat> cb = cbf.insertCollection(em, Cat.class, "kittens", "cat")
    .from(Cat.class, "c")
    .bind("cat.id", 2)
    .bind("cat.kittens.id").select("c.kittens.id)
    .where("c.id").eq(1);
----

The alias `cat` or in general, an insert collection statement alias only allows access to the join or collection table related attributes.
Generally, these attributes are

* The source id i.e. `cat.id`
* The target id i.e. `cat.kittens.id`
* The collection index/key i.e. `KEY(cat.kittens)`

The logical SQL for this _kittens copying query_ looks like

[source,sql]
----
INSERT INTO Cat.kittens(id, _collection.id)
SELECT :param_1, kittens_1.id
FROM Cat c
LEFT JOIN c.kittens kittens_1
WHERE c.id = :param_2
----

This will copy all kittens that are associated with the cat with id 1 to the kittens of the cat with id 2.

=== CTE support

If the underlying DBMS supports the use of CTEs on _modification_ statements, you can make use of those by defining them via link:{core_jdoc}/persistence/CTEBuilder.html#with(java.lang.Class)[`with()`].
For further information on this, check out the <<ctes,CTE chapter>>.

// TODO: When fixing #337 we could actually fallback to inlining for non-recursive CTEs on DBMS that don't support CTEs

=== RETURNING clause support

The `RETURNING` clause allows to return values to the client based on the modified entities of a DML statement.
Every DML statement can return any attributes of the entities that the statement modified.

All query builders for DML statements provide link:{core_jdoc}/persistence/ModificationCriteriaBuilder.html#getWithReturningQuery(java.lang.String,%20java.lang.Class)[`getWithReturningQuery()`] variants
for creating a JPA `TypedQuery` from specifiable attributes which should be _returned_ for modified entities.

The `TypedQuery` instance always returns a single `ReturningResult`. Calling `getResultList()` will just wrap the result of `getSingleResult()` in a list.

NOTE: Although the builder returns a `TypedQuery` which normally doesn't require a transaction, you have to execute such a query within an active transaction since it actually modifies entities.

TIP: For every `getWithReturningQuery()` variant, there exists a `executeWithReturning()` variant that can be used as a short hand for `getWithReturningQuery().getSingleResult()`.

A `ReturningResult` basically gives you access to the update count via link:{core_jdoc}/persistence/ReturningResult.html#getUpdateCount()[`getUpdateCount()`]
and a result list, representing the attributes of modified entities that were requested to be returned, via link:{core_jdoc}/persistence/ReturningResult.html#getResultList()[`getResultList()`].
In addition to that, it also offers access to the _last returned result_ via link:{core_jdoc}/persistence/ReturningResult.html#getLastResult()[`getLastResult()`], but this might get removed in the future.

NOTE: As you will see in the <<updatable-ctes,next chapter>>, on some DBMS you can even _pipe_ data returned by DML into other queries.

The following examples will show how the different `executeWithReturning()` variants can be used.

==== RETURNING from DELETE statement

Let's see how we can retrieve the names of cats that have been deleted.

[source,java]
----
DeleteCriteriaBuilder<Cat> cb = cbf.delete(em, Cat.class, "cat")
    .where("cat.name").like().value("Billy%").noEscape();
ReturningResult<String> result = cb.executeWithReturning("name", String.class);
List<String> names = result.getResultList();
----

Make sure your DBMS supports returning non-generated columns in the <<anchor-dml-dbms-compatibility,DBMS compatibility matrix>>.

[source,sql]
----
DELETE FROM Cat cat
WHERE cat.name LIKE :param_1
RETURNING name
----

==== RETURNING from UPDATE statement

[source,java]
----
UpdateCriteriaBuilder<Cat> cb = cbf.update(em, Cat.class, "cat")
    .setExpression("cat.name", "UPPER(cat.name)")
    .where("cat.name").like().value("Billy%").noEscape();
ReturningResult<Tuple> result = cb.executeWithReturning("id", "name");
List<Tuple> updatedCatIdAndNames = result.getResultList();
----

Also make sure your DBMS supports returning multiple modified rows in the <<anchor-dml-dbms-compatibility,DBMS compatibility matrix>>.

[source,sql]
----
UPDATE Cat cat
SET cat.name = UPPER(cat.name)
WHERE cat.name LIKE :param_1
RETURNING id, name
----

==== RETURNING from INSERT-SELECT statement

[source,java]
----
InsertCriteriaBuilder<Cat> cb = cbf.insert(em, Pet.class)
    .from(Cat.class, "c")
    .bind("cat").select("c")
    .where("owner").isNotNull();
ReturningResult<Pet> result = cb.executeWithReturning(new ReturningObjectBuilder<Pet>() {
    @Override
    public <X extends ReturningBuilder<X>> void applyReturning(X returningBuilder) {
        returningBuilder.returning("id");
    }

    @Override
    public Pet build(Object[] tuple) {
        return new Pet((Long) tuple[0]);
    }

    @Override
    public List<T> buildList(List<T> list) {
        return list;
    }
});
List<Pet> createdPetIds = result.getResultList();
----

Although not very useful, this will return pet objects with the ids of the inserted pet entities set.

[source,sql]
----
INSERT INTO Pet(cat)
SELECT c
FROM Cat c
WHERE c.owner IS NOT NULL
RETURNING id
----

[[anchor-dml-dbms-compatibility]]
=== DBMS compatibility

Although it might be possible to retrieve other columns based on identifiers for DBMS that don't support `RETURNING` all columns natively, there is no emulation implemented yet.

[width="100%",options="header,footer"]
|====================
| *DBMS*     | RETURNING generated   | RETURNING multiple rows   | RETURNING all
| PostgreSQL | yes                   | yes                       | yes
| MySQL      | yes                   | no                        | no
| H2         | yes                   | no                        | no
| Oracle     | yes                   | yes                       | yes
| SQL Server | yes                   | yes                       | yes
| DB2        | yes                   | yes                       | yes
|====================